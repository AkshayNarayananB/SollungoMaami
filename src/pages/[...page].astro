---
// 1. ENABLE SSR (Live Mode)
export const prerender = false;

// --- CACHE HEADERS (Add this block) ---
// 1. Cache on Vercel (CDN) for 1 hour (3600s).
// 2. If 1 hour passes, serve "stale" content for another 10 mins (600s)
//    while Vercel fetches new posts in the background.
Astro.response.headers.set(
  'Cache-Control', 
  'public, max-age=0, s-maxage=3600, stale-while-revalidate=600'
);
// --------------------------------------

// Component imports
import Main from "../layouts/MainLayout.astro";
import PostCard from "../components/PostCard.astro";
import Pagination from "../components/controllers/Pagination.astro";

// Firebase Imports
import { db } from '../lib/firebase';
import { collection, getDocs, query, orderBy } from 'firebase/firestore';

// 2. Handle Pagination Logic
// We use a rest parameter [...page] so this file handles "/", "/2", "/3", etc.
const { page: pageParam } = Astro.params;

// If pageParam is undefined (root url), default to 1.
// We also use explicit base-10 parsing for safety.
const currentPage = pageParam ? parseInt(pageParam, 10) : 1;
const pageSize = 6;

// 3. Fetch Data from Firebase
// (Fetching all docs is fine for <500 posts. For larger scales, consider Firestore cursors)
const q = query(collection(db, "blog"), orderBy("published", "desc"));
const querySnapshot = await getDocs(q);
const allDocs = querySnapshot.docs;

const totalPosts = allDocs.length;
const lastPage = Math.max(1, Math.ceil(totalPosts / pageSize)); // Ensure lastPage is at least 1

// Calculate start/end indices
const start = (currentPage - 1) * pageSize;
const end = start + pageSize;
const paginatedDocs = allDocs.slice(start, end);

// 4. Map Data to match EXACTLY what your template expects
const formattedEntries = paginatedDocs.map(doc => {
  const data = doc.data();
  
  // Calculate Reading Time on the fly
  const content = data.content || "";
  const wordCount = content.split(/\s+/g).length;
  const time = Math.ceil(wordCount / 200);

  return {
    id: doc.id,
    data: {
      title: data.title,
      published: data.published ? data.published.toDate() : new Date(),
      category: data.category,
      tags: data.tags || [],
      description: data.description,
      image: data.image,
    },
    // Mocking "Astro Content Collection" structure for compatibility
    rendered: {
      metadata: {
        frontmatter: {
          readingMetadata: {
            time: time,
            wordCount: wordCount
          }
        }
      }
    }
  };
});

// 5. Recreate the 'page' object for the Pagination Component
const page = {
  data: formattedEntries,
  start,
  end: Math.min(end, totalPosts),
  size: pageSize,
  total: totalPosts,
  currentPage,
  lastPage,
  url: {
    // Logic: Page 1 is always '/', subsequent pages are '/2', '/3'
    current: currentPage === 1 ? '/' : `/${currentPage}`,
    prev: currentPage > 1 ? (currentPage - 1 === 1 ? '/' : `/${currentPage - 1}`) : undefined,
    next: currentPage < lastPage ? `/${currentPage + 1}` : undefined,
  }
};
---

<Main>
  <div class="space-y-8">
    <div class="w-full space-y-4">
      {
        page.data.map((entry, index) => (
          <div
            class="onload-animation"
            style={`animation-delay: calc(var(--onload-animation-delay) + ${index + 1} * var(--onload-animation-interval));`}
          >
            <PostCard
              id={entry.id}
              title={entry.data.title}
              published={entry.data.published}
              category={entry.data.category}
              tags={entry.data.tags}
              description={entry.data.description}
              image={entry.data.image}
              readingMetadata={
                (entry.rendered!.metadata as any).frontmatter.readingMetadata
              }
            />
          </div>
        ))
      }
    </div>
    <Pagination
      class="onload-animation"
      lastPage={page.lastPage}
      current={page.currentPage}
      prevURL={page.url.prev}
      nextURL={page.url.next}
      style={`animation-delay: calc(var(--onload-animation-delay) + ${page.data.length + 1} * var(--onload-animation-interval));`}
    />
  </div>
</Main>
